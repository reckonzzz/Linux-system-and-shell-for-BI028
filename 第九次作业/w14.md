# 1 Tuples
#### 1.1 zip函数
>我们知道，内置函数zip可以将两个或多个列表合并为一个列表，每个列表的元素就是最初所有列表中某个相同位置的元素构成的元组，也就是一个等长元组的列表。
(a) 如果需要合并的列表的长度不同，则结果会什么样？举例说明
(b) 如果我们想要用zip函数将产生的列表恢复为原有的列表，该怎么做？
(c) enumerate函数也可以遍历列表，产生一个元组的列表生成器，与zip函数的区别是什么？

(a) 只和并对应的位置，多余的不合并。元素个数与最短的列表一致.
```
>>> a = [1,2,3,4,5]
>>> b = [1,2,3,4,5,6]
>>> zip(a,b)
[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]
```
(b)对结果再次进行zip即可，但要加上*来代表解压。
```
>>> zip(*c)
[(1, 2, 3, 4, 5), (1, 2, 3, 4, 5)]
```
(c)enumerate()用于将一个可遍历的数据对象（如：列表、元组、字符串等）组合为一个索引序列，同时列出数据和数据下标。
zip()该函数用于将多个可迭代对象作为参数，依次将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。
前者能够对一个列表等加上索引，后者是对两个及以上列表合并形成一个列表对象。

#### 1.2 K-L散度
>课上我们学习了如何计算两个向量的L1和L2距离，现在我们将针对一类特殊的向量构建K-L 散度距离（K-L divergence）。这种向量是一种组成向量（compositional vector）。
写一个函数实现K-L散度的计算，并举例说明。

```
from math import *


def kl_divergence(a, b):
    sum1 = a[0] * log(a[0] / b[0], e)
    sum2 = a[1] * log(a[1] / b[1], e)
    return sum1 + sum2


a = (0.5, 0.5)
b = (0.25, 0.75)
print(kl_divergence(a, b))
```
结果为0.14384103622589042

# 2 Dictionaries
#### 2.1 从列表到字典
我们知道，列表中可存在相同的元素，写一个函数，统计输入列表中每个元素的发生次数（occurrence），返回结果为字典。
```
def count_occ(input_list):
    output_dict = {}
    for i in input_list:
        if i in output_dict:
            output_dict[i] = output_dict[i] + 1
        else:
            output_dict[i] = 1
    return output_dict


a = ['a', 'b', 'a', 'c', 'd', 'b', 'c']
result = count_occ(a)
print(result)
```
结果为：{'a': 2, 'b': 2, 'c': 2, 'd': 1}
#### 2.2 get方法
字典有一种方法get，与 getitem 不同的是，这种方法可以设定默认的返回值，我们是否可以将其应用在上题中呢？请该写上一题的函数。
```
def count_occ(input_list):
    output_dict = {}
    for i in input_list:
        count = output_dict.get(i, 0)
        output_dict[i] = count + 1
    return output_dict


a = ['a', 'b', 'a', 'c', 'd', 'b', 'c']
result = count_occ(a)
print(result)
```
结果是：{'a': 2, 'b': 2, 'c': 2, 'd': 1}
#### 2.3 随机DNA序列的密码子表
(a) 写一个函数，按照约定的核苷酸A/T/C/G的比例，生成指定长度的随机DNA序列
(b) 验证产生随机序列的比例随长度的变化与设定之间的差异，可用卡方检验或Fisher’s exact验证
(c) 写一个函数，对产生的随机序列，针对不同的开放阅读框，统计每种密码子的比例
(d) 从Genbank中获取某个物种基因组的CDS，分析其与随机序列之间的密码子使用是否存在差异，也就是说我们需要评估密码子的使用是否是随机的
#### 2.4 稀疏向量和稀疏矩阵的表示
我们可以用列表表示向量，用列表的列表来表示矩阵。对于稠密向量（dense vector）和矩阵（dense matrix）来说，这是合理的。但是对于稀疏向量（sparse vector）和稀疏矩阵（sparse matrix）来说，超过一半的元素的值都是0，这样如果仍然用列表表示就有点浪费了。在实际工作中，我们常常会用字典来表示稀疏向量和稀疏矩阵。你觉得该怎么表示？尝试写出你的思路，并举例说明。
#### 2.5 反向查找
一般来说，对于字典，我们都用key去查找value。能否实现这种方法，反过来，用值去查找对应的key？这个在现实中有着非常广泛的应用。需要注意的是，key是唯一的，而value非唯一。
# 3 Sets
#### 3.1 基于K-mer的序列相似性
有两个不同的DNA序列，我们想要计算基于k-mer的两个序列的Gaussian相似性。也即
(a) 分别计算两序列的k-mer occurrences
(b) 两序列的k-mer组成存在差异，因此必须进行对齐处理，也就是让两者的k-mer有相同的组成
(c) 计算两个向量的Gaussian相似性分值，采用类似于Gaussian分布的计算公式。
# 4 File I/O
#### 4.1 模仿写作
从网络上收集某作家（注意，尽量用英文的，中文文章需要分词）的若干作品，统计词频，然后按照这个词频表生成一篇指定长度的作品，将其写到文件中。当然，这样生成的文章必然是乱七八糟的，为什么？能否解释一下。